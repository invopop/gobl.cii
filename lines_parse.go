package cii

import (
	"strings"

	"github.com/invopop/gobl/bill"
	"github.com/invopop/gobl/catalogues/iso"
	"github.com/invopop/gobl/cbc"
	"github.com/invopop/gobl/l10n"
	"github.com/invopop/gobl/num"
	"github.com/invopop/gobl/org"
	"github.com/invopop/gobl/tax"
)

func goblAddLines(in *Transaction, out *bill.Invoice) error {
	items := in.Lines
	lines := make([]*bill.Line, 0, len(items))

	for _, it := range items {
		price, err := num.AmountFromString(it.Agreement.NetPrice.Amount)
		if err != nil {
			return err
		}
		l := &bill.Line{
			// Index is generated by GOBL
			// If Quantity is not present, assume 1
			Quantity: num.MakeAmount(1, 0),
			Item: &org.Item{
				Name:  strings.TrimSpace(it.Product.Name),
				Price: &price,
			},
			Taxes: tax.Set{
				{
					Category: cbc.Code(it.TradeSettlement.ApplicableTradeTax[0].TypeCode),
				},
			},
		}

		if it.Quantity != nil && it.Quantity.Quantity != nil {
			l.Quantity, err = num.AmountFromString(it.Quantity.Quantity.Amount)
			if err != nil {
				return err
			}
		}

		if it.Quantity.Quantity.UnitCode != "" {
			u := cbc.Code(it.Quantity.Quantity.UnitCode)
			l.Item.Unit = goblUnitFromUNECE(u)
		}

		if it.Product.SellerAssignedID != nil {
			l.Item.Ref = cbc.Code(*it.Product.SellerAssignedID)
		}

		if it.Product.BuyerAssignedID != nil {
			if l.Item.Identities == nil {
				l.Item.Identities = make([]*org.Identity, 0)
			}
			l.Item.Identities = append(l.Item.Identities, &org.Identity{
				Code: cbc.Code(*it.Product.BuyerAssignedID),
			})
		}

		if it.Product.GlobalID != nil {
			if l.Item.Identities == nil {
				l.Item.Identities = make([]*org.Identity, 0)
			}
			l.Item.Identities = append(l.Item.Identities, &org.Identity{
				// This label corresponds to a code from the ISO 6523 ICD List. Mapping is not yet supported
				Ext: tax.Extensions{
					iso.ExtKeySchemeID: cbc.Code(it.Product.GlobalID.SchemeID),
				},
				Code: cbc.Code(it.Product.GlobalID.Value),
			})
		}

		if it.Product.Description != nil {
			l.Item.Description = strings.TrimSpace(*it.Product.Description)
		}

		if it.Product.Origin != nil {
			l.Item.Origin = l10n.ISOCountryCode(*it.Product.Origin)
		}

		if it.LineDoc != nil && len(it.LineDoc.Note) > 0 {
			l.Notes = make([]*org.Note, 0, len(it.LineDoc.Note))
			for _, note := range it.LineDoc.Note {
				n := &org.Note{}
				if note.Content != "" {
					n.Text = strings.TrimSpace(note.Content)
				}
				if note.SubjectCode != "" {
					n.Key = cbc.Key(note.SubjectCode)
				}
				l.Notes = append(l.Notes, n)
			}
		}

		if len(it.TradeSettlement.ApplicableTradeTax) > 0 {
			for i, tax := range it.TradeSettlement.ApplicableTradeTax {
				if tax.RateApplicablePercent != "" {
					if !strings.HasSuffix(tax.RateApplicablePercent, "%") {
						tax.RateApplicablePercent += "%"
					}
					p, err := num.PercentageFromString(tax.RateApplicablePercent)
					if err != nil {
						return err
					}
					l.Taxes[i].Percent = &p
				}
			}
		}

		if len(it.TradeSettlement.AllowanceCharge) > 0 {
			l, err = getLineCharges(it.TradeSettlement.AllowanceCharge, l)
			if err != nil {
				return err
			}
		}

		if len(it.Product.Characteristics) > 0 {
			l.Item.Meta = make(cbc.Meta)
			for _, char := range it.Product.Characteristics {
				key := formatKey(char.Description)
				l.Item.Meta[key] = char.Value
			}
		}

		l.Cost = getLineCostCode(in, it)

		lines = append(lines, l)
	}

	out.Lines = lines
	return nil
}

// getLineCostCode retrieves the cost code for a line item
func getLineCostCode(in *Transaction, it *Line) cbc.Code {
	// Line settlement cost code takes precedence over agreement settlement cost code
	if it.TradeSettlement.Cost != nil {
		return cbc.Code(it.TradeSettlement.Cost.ID)
	} else if in.Settlement != nil && in.Settlement.Cost != nil {
		return cbc.Code(in.Settlement.Cost.ID)
	}

	return cbc.CodeEmpty
}

// getLineCharges parses inline charges and discounts from the CII document
func getLineCharges(alwcs []*AllowanceCharge, l *bill.Line) (*bill.Line, error) {
	for _, ac := range alwcs {
		if ac.ChargeIndicator.Value {
			c, err := goblNewLineCharge(ac)
			if err != nil {
				return nil, err
			}
			if l.Charges == nil {
				l.Charges = make([]*bill.LineCharge, 0)
			}
			l.Charges = append(l.Charges, c)
		} else {
			d, err := goblNewLineDiscount(ac)
			if err != nil {
				return nil, err
			}
			if l.Discounts == nil {
				l.Discounts = make([]*bill.LineDiscount, 0)
			}
			l.Discounts = append(l.Discounts, d)
		}
	}
	return l, nil
}
